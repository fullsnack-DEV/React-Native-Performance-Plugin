import react from "@vitejs/plugin-react";
import reactNativeWeb from "vite-plugin-react-native-web";
import process$1 from "node:process";
import path from "node:path";
import fs, { readFileSync } from "node:fs";
import ejs from "ejs";
import { fileURLToPath } from "node:url";
import { transformWithEsbuild } from "vite";
import fs$1 from "node:fs/promises";
import maybeDtsPlugin from "vite-plugin-dts";
import assert from "node:assert";
const rozeniteServerPlugin = () => {
  return {
    name: "rozenite-server-plugin",
    config(config) {
      const projectRoot = config.root ?? process$1.cwd();
      config.build ?? (config.build = {});
      config.build.lib = {
        entry: path.resolve(projectRoot, "metro.ts"),
        formats: ["es", "cjs"],
        fileName: (format) => `metro.${format === "es" ? "js" : "cjs"}`
      };
      config.build.ssr = true;
      config.build.rollupOptions = {
        output: {
          exports: "named",
          interop: "auto"
        }
      };
    }
  };
};
const loadConfig = async (configPath) => {
  const absoluteConfigPath = path.resolve(process.cwd(), configPath);
  if (!fs.existsSync(absoluteConfigPath)) {
    throw new Error(`Configuration file not found: ${absoluteConfigPath}`);
  }
  try {
    const configContent = await fs.promises.readFile(
      absoluteConfigPath,
      "utf-8"
    );
    const result = await transformWithEsbuild(
      configContent,
      absoluteConfigPath,
      {
        loader: "ts",
        format: "cjs",
        target: "esnext"
      }
    );
    const moduleExports = {};
    const module = { exports: moduleExports };
    const exports = moduleExports;
    const moduleFunction = new Function("module", "exports", result.code);
    moduleFunction(module, exports);
    const configModule = module.exports;
    const config = configModule.default || configModule;
    if (!config || typeof config !== "object") {
      throw new Error("Configuration must export an object");
    }
    return config;
  } catch (error) {
    if (error instanceof Error) {
      throw new Error(
        `Failed to load configuration from ${configPath}: ${error.message}`
      );
    }
    throw new Error(`Failed to load configuration from ${configPath}`);
  }
};
const getPackageJSON = async (projectRoot) => {
  const packageJSONPath = path.join(projectRoot, "package.json");
  const packageJSON = await fs$1.readFile(packageJSONPath, "utf8");
  return JSON.parse(packageJSON);
};
const TEMPLATES_DIR = path.resolve(
  fileURLToPath(import.meta.url),
  "..",
  "..",
  "templates"
);
const PANELS_DIR = "./panels";
const rozeniteClientPlugin = () => {
  let projectRoot = process$1.cwd();
  let viteServer = null;
  let rozeniteConfig = null;
  const getRozeniteConfig = () => {
    if (!rozeniteConfig) {
      throw new Error("rozenite.config.ts not found");
    }
    return rozeniteConfig;
  };
  const getPanels = () => {
    return getRozeniteConfig().panels.map((entry) => {
      const name = path.basename(entry.source, path.extname(entry.source));
      return {
        name,
        label: entry.name,
        sourceFile: path.resolve(projectRoot, entry.source),
        htmlFile: name + ".html"
      };
    });
  };
  const PANEL_TEMPLATE = path.join(TEMPLATES_DIR, "panel.ejs");
  const generatePanelHtmlContent = (panel) => {
    const template = fs.readFileSync(PANEL_TEMPLATE, "utf-8");
    const relativePath = path.relative(projectRoot, panel.sourceFile);
    return ejs.render(template, {
      panelName: panel.name,
      panelFile: relativePath
    });
  };
  return {
    name: "rozenite-client-plugin",
    async config(config) {
      var _a;
      if (config.root) {
        projectRoot = config.root;
      }
      rozeniteConfig = await loadConfig(
        path.resolve(projectRoot, "rozenite.config.ts")
      );
      const panels = getPanels();
      config.server ?? (config.server = {});
      config.server.open = false;
      config.server.port = 8888;
      config.build ?? (config.build = {});
      (_a = config.build).rollupOptions ?? (_a.rollupOptions = {});
      config.build.rollupOptions.input = {
        ...config.build.rollupOptions.input,
        ...Object.fromEntries(
          panels.map((panel) => [panel.name, panel.htmlFile])
        )
      };
    },
    resolveId(id) {
      const isPanel = getPanels().some((panel) => panel.htmlFile === id);
      if (isPanel) {
        return id;
      }
      return null;
    },
    load(id) {
      const panel = getPanels().find((panel2) => panel2.htmlFile === id);
      if (panel) {
        return generatePanelHtmlContent(panel);
      }
      return null;
    },
    async configureServer(server) {
      viteServer = server;
      const packageJSON = await getPackageJSON(projectRoot);
      server.middlewares.use((req, res, next) => {
        res.setHeader("Access-Control-Allow-Origin", "*");
        res.setHeader(
          "Access-Control-Allow-Methods",
          "GET, POST, PUT, DELETE, OPTIONS"
        );
        res.setHeader(
          "Access-Control-Allow-Headers",
          "Content-Type, Authorization"
        );
        if (req.method === "OPTIONS") {
          res.statusCode = 200;
          res.end();
          return;
        }
        const panels = getPanels();
        const url = req.url || "/";
        if (url === "/rozenite.json") {
          res.setHeader("Content-Type", "application/json");
          res.end(
            JSON.stringify(
              {
                name: packageJSON.name,
                version: packageJSON.version,
                description: packageJSON.description,
                panels: panels.map((panel2) => ({
                  name: panel2.label,
                  source: "/" + panel2.htmlFile
                }))
              },
              null,
              2
            )
          );
          return;
        }
        const panel = panels.find((panel2) => "/" + panel2.htmlFile === url);
        if (panel) {
          const htmlContent = generatePanelHtmlContent(panel);
          server.transformIndexHtml(req.url || "/", htmlContent).then((html) => {
            res.setHeader("Content-Type", "text/html");
            res.end(html);
          }).catch((err) => {
            next(err);
          });
          return;
        }
        next();
      });
    },
    watchChange(id, change) {
      if (change.event !== "create" && change.event !== "delete") {
        return;
      }
      const relativePath = path.relative(projectRoot, id);
      if (!relativePath.startsWith(PANELS_DIR)) {
        return;
      }
      viteServer == null ? void 0 : viteServer.ws.send({
        type: "full-reload",
        path: "/"
      });
    },
    async generateBundle() {
      const panels = getPanels();
      const packageJSON = await getPackageJSON(projectRoot);
      this.emitFile({
        type: "asset",
        fileName: "rozenite.json",
        source: JSON.stringify({
          name: packageJSON.name,
          version: packageJSON.version,
          description: packageJSON.description,
          panels: panels.map((panel) => ({
            name: panel.label,
            source: "/" + panel.htmlFile
          }))
        })
      });
    }
  };
};
const rozeniteReactNativePlugin = () => {
  return {
    name: "rozenite-react-native-plugin",
    config(config) {
      var _a;
      const projectRoot = config.root ?? process.cwd();
      config.build ?? (config.build = {});
      (_a = config.build).rollupOptions ?? (_a.rollupOptions = {});
      config.build.lib = {
        entry: path.resolve(projectRoot, "react-native.ts"),
        fileName: (format) => `react-native.${format === "es" ? "js" : "cjs"}`
      };
      config.build.rollupOptions.external = (id) => {
        if (id.startsWith("node:")) {
          return true;
        }
        return !id.startsWith(".") && !path.isAbsolute(id);
      };
      config.build.rollupOptions.output = [
        {
          format: "es",
          exports: "named",
          interop: "auto",
          chunkFileNames: "[name].js",
          ...config.build.rollupOptions.output ?? {}
        },
        {
          format: "cjs",
          exports: "named",
          interop: "auto",
          chunkFileNames: "[name].cjs",
          ...config.build.rollupOptions.output ?? {}
        }
      ];
      delete config.build.rollupOptions.input;
    }
  };
};
const REQUIRE_REGEX = /require\s*\(\s*['"`]([^'"`]+)['"`]\s*\)/g;
const IMPORT_PREFIX = "__import_";
function requirePlugin() {
  let input = "";
  let inputName = "";
  let isDevMode = false;
  const moduleToChunkMap = /* @__PURE__ */ new Map();
  const moduleInfoMap = /* @__PURE__ */ new Map();
  const extractModuleName = (filePath) => {
    return path.basename(filePath).replace(/\.[^/.]+$/, "");
  };
  const getFileExtension = (format) => {
    return format === "es" ? ".js" : ".cjs";
  };
  const findRequireStatements = (code) => {
    const requires = /* @__PURE__ */ new Set();
    let match;
    REQUIRE_REGEX.lastIndex = 0;
    while ((match = REQUIRE_REGEX.exec(code)) !== null) {
      const moduleName = match[1];
      if (moduleName && moduleName.trim()) {
        requires.add(moduleName.trim());
      }
    }
    return requires;
  };
  const transformRequireToImports = (code) => {
    const imports = [];
    const importMap = /* @__PURE__ */ new Map();
    const requires = findRequireStatements(code);
    requires.forEach((moduleName, index) => {
      const importName = `${IMPORT_PREFIX}${index}`;
      importMap.set(moduleName, importName);
      imports.push(`import * as ${importName} from '${moduleName}';`);
    });
    let transformedCode = code.replace(REQUIRE_REGEX, (match, moduleName) => {
      const importName = importMap.get(moduleName.trim());
      return importName || match;
    });
    if (imports.length > 0) {
      transformedCode = imports.join("\n") + "\n" + transformedCode;
    }
    return { code: transformedCode, imports, importMap };
  };
  const transformRequireToChunkReferences = (code, format) => {
    return code.replace(REQUIRE_REGEX, (match, moduleName) => {
      const chunkName = moduleToChunkMap.get(moduleName.trim());
      if (chunkName) {
        const extension = getFileExtension(format);
        return `require('./${chunkName}${extension}')`;
      }
      return match;
    });
  };
  return {
    name: "vite-require-plugin",
    configResolved(config) {
      isDevMode = config.command === "serve";
    },
    transform(code, id) {
      if (!isDevMode || id !== input) {
        return null;
      }
      try {
        const result = transformRequireToImports(code);
        return {
          code: result.code,
          map: null
        };
      } catch (error) {
        console.error("Error transforming require statements:", error);
        return null;
      }
    },
    async buildStart(options) {
      try {
        assert(Array.isArray(options.input), "input must be an array");
        assert(
          options.input.length === 1,
          "input must be an array with one entry"
        );
        input = options.input[0];
        inputName = extractModuleName(input);
        const code = readFileSync(input, "utf-8");
        const requires = findRequireStatements(code);
        for (const req of requires) {
          try {
            const resolved = await this.resolve(req, input);
            if (resolved) {
              const fileName = extractModuleName(resolved.id);
              this.addWatchFile(resolved.id);
              this.emitFile({
                type: "chunk",
                id: resolved.id,
                fileName
              });
              moduleToChunkMap.set(req, fileName);
              moduleInfoMap.set(req, {
                fileName,
                resolvedId: resolved.id
              });
            } else {
              console.warn(`Could not resolve module: ${req}`);
            }
          } catch (error) {
            console.error(`Error resolving module ${req}:`, error);
          }
        }
      } catch (error) {
        console.error("Error in buildStart:", error);
        throw error;
      }
    },
    renderChunk(code, chunk, options) {
      try {
        const additionalChunkNames = Array.from(moduleToChunkMap.values());
        if (additionalChunkNames.includes(chunk.fileName)) {
          chunk.fileName = chunk.fileName + getFileExtension(options.format);
        }
        if (chunk.name !== inputName) {
          return null;
        }
        const transformedCode = transformRequireToChunkReferences(
          code,
          options.format
        );
        return {
          code: transformedCode,
          map: null
        };
      } catch (error) {
        console.error("Error in renderChunk:", error);
        return null;
      }
    }
  };
}
const dtsPlugin = "default" in maybeDtsPlugin ? maybeDtsPlugin.default : maybeDtsPlugin;
const rozenitePlugin = () => {
  const isServer = process.env.VITE_ROZENITE_TARGET === "server";
  const isReactNative = process.env.VITE_ROZENITE_TARGET === "react-native";
  if (isServer) {
    return [rozeniteServerPlugin(), dtsPlugin()];
  } else if (isReactNative) {
    return [
      react(),
      requirePlugin(),
      rozeniteReactNativePlugin(),
      dtsPlugin()
    ];
  }
  return [
    react(),
    // @ts-expect-error: TypeScript gets confused by the dual export
    reactNativeWeb(),
    rozeniteClientPlugin()
  ];
};
export {
  rozenitePlugin
};
